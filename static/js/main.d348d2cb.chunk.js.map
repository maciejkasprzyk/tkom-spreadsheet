{"version":3,"sources":["components/Spreadsheet.module.scss","parser/parserPostProcessors.js","App.js","components/Spreadsheet.js","mobx/SpreadsheetStore.js","parser/parser.js","parser/grammar.js","parser/tokens.js","serviceWorker.js","index.js"],"names":["module","exports","postProcessors","store","SpreadsheetStore","App","useEffect","r","cells","set","x","eval","className","y","onCellSet","cell","value","letterLabelGenerator","nextChar","c","String","fromCharCode","charCodeAt","label","slice","reverse","join","index","length","push","observer","props","initial","useState","editing","_setEditing","useEditing","isEditing","setEditing","onInputKeyDown","e","keyCode","target","blur","rowLabelsGen","style","Spreadsheet","Array","fill","map","_","i","key","next","row","j","onClick","onKeyDown","onFocus","formula","parentNode","classList","add","focus","onBlur","remove","autoFocus","error","Parser","require","Cell","sheet","observers","subjects","this","string","unregisterFromAllSubjects","charAt","isFormula","parser","getCellByLabel","bind","feed","substring","results","cellsReferenced","observe","parseFloat","isNaN","topologicalSort","calculateValue","message","unregisterObserver","registerObserver","visited","sorted","dfs","includes","Error","neighbour","indexOf","pop","observable","cellLabel","toUpperCase","letters","digits","y_index","parseInt","x_index","nearley","getByLabel","console","log","grammar","Grammar","fromCompiled","s","moo","tokens","post","lexer","states","tok","call","type","Lexer","ParserRules","a","has","plus","b","minus","asterisk","slash","lparen","rparen","data","number","func","func_call","func_call_end","func_name","args","sum","range","list","colon","label1","label2","semicolon","ParserStart","window","main","whitespace","match","lineBreaks","func_args","Boolean","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.d348d2cb.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"Spreadsheet\":\"Spreadsheet_Spreadsheet__2MlAU\",\"focus\":\"Spreadsheet_focus__2PRei\",\"error\":\"Spreadsheet_error__2OBGk\"};","// Parser postprocessor functions are dynamically added to this module before constructing the parser.\n\n// This module exists in order to avoid cyclic reference between modules\n// Nearley parser dont take any arguments, it can only call external functions from different modules.\n// I need parser to call external function to get value of call based on its label, that function exists in SpreadSheetStore module.\n// Its the same module that creates and uses parsers so it would be a cyclic reference.\n// To avoid that parser calls functions from this module, which are dynamically sets by parser wrapper.\n\n\n// Alternative solution would be to allow cyclic reference, but this way it seems more isolated.\n\nexport const postProcessors = {};\n","/* eslint-disable no-eval */\nimport React, {useEffect} from 'react';\nimport './App.css';\nimport Spreadsheet from \"./components/Spreadsheet\";\nimport {SpreadsheetStore} from \"./mobx/SpreadsheetStore\";\n\nconst store = new SpreadsheetStore(5, 10);\n\nfunction App() {\n\n  useEffect(() => {\n\n    let r = 0;\n\n    store.cells[r][0].set(\"Self reference\");\n    store.cells[r][1].set(\"=B1\");\n\n    store.cells[++r][0].set(\"Cycle\");\n    store.cells[r][1].set(\"=C2\");\n    store.cells[r][2].set(\"=B2\");\n\n    store.cells[++r][0].set(\"Auto update working\");\n    store.cells[r][2].set(\"=B3\");\n    store.cells[r][3].set(\"=B3+C3\");\n    store.cells[r][1].set(\"coś\");\n\n    store.cells[++r][0].set(\"Simple math\");\n    let x = \"1+2*(5+5)+2/3+((1*3))/2\";\n    store.cells[r][1].set(\"=\" + x);\n    store.cells[r][2].set(`is ${eval(x)}`);\n\n    store.cells[++r][0].set(\"Complex math\");\n    x = \"1-1+2*(5+5)+2/3+((1*3))/2\";\n    store.cells[r][1].set(\"=\" + x);\n    store.cells[r][2].set(`is ${eval(x)}`);\n\n    store.cells[++r][0].set(\"Negative numbers\");\n    x = \"1-1+1\";\n    store.cells[r][1].set(\"=\" + x);\n    store.cells[r][2].set(`is ${eval(x)}`);\n\n    store.cells[++r][0].set(\"Math with labels\");\n    store.cells[r][1].set('=C7+D7*E7');\n    store.cells[r][2].set('2');\n    store.cells[r][3].set('2');\n    store.cells[r][4].set('2');\n\n    store.cells[++r][0].set(\"Invalid formulas\");\n    store.cells[r][1].set('=C7D7*E7');\n    store.cells[r][2].set('=as325');\n    store.cells[r][3].set('=1**2');\n\n    store.cells[++r][0].set(\"* and / order\");\n    x = \"3/3*3\";\n    store.cells[r][1].set(\"=\" + x);\n    store.cells[r][2].set(`is ${eval(x)}`);\n\n    store.cells[++r][0].set(\"- at the begging and --\");\n    x = \"-1+2\";\n    store.cells[r][1].set(\"=\" + x);\n    store.cells[r][2].set(`is ${eval(x)}`);\n\n\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <Spreadsheet\n        x={store.x}\n        y={store.y}\n        cells={store.cells}\n        onCellSet={(cell, value) => {\n          cell.set(value)\n        }}\n      />\n    </div>\n  );\n}\n\nexport default App;\n\n","import React, {useState} from 'react';\nimport {observer} from \"mobx-react\";\nimport style from './Spreadsheet.module.scss'\nimport PropTypes from 'prop-types'\n\n/**\n * It returns strings like this: \"A\", \"B\", ... , \"Z\", \"AA\", \"AB\", ...\n */\nfunction* letterLabelGenerator() {\n  function nextChar(c) {\n    return String.fromCharCode(c.charCodeAt(0) + 1);\n  }\n\n  const label = ['A'];\n  while (true) {\n    yield label.slice().reverse().join(\"\");\n    let index = 0;\n    label[index] = nextChar(label[index]);\n    while (label[index].charCodeAt(0) > 'Z'.charCodeAt(0)) {\n      label[index] = 'A';\n      index++;\n      if (index >= label.length) {\n        label.push('A');\n        break;\n      }\n      label[index] = nextChar(label[index]);\n    }\n  }\n}\n\n\nconst Spreadsheet = props => {\n\n  let [isEditing, setEditing] = useEditing();\n\n\n  const onInputKeyDown = (e) => {\n    if (e.keyCode === 13) {\n      e.target.blur();\n    }\n  };\n\n  const onBlur = (e, cell) => {\n    props.onCellSet(cell, e.target.value);\n    e.target.parentNode.classList.remove(style.focus);\n    if (isEditing(cell)){\n      setEditing(null);\n    }\n  };\n\n  const onFocus = (e, cell) => {\n    e.target.value = cell.formula ? cell.formula : cell.value;\n    e.target.parentNode.classList.add(style.focus)\n  };\n\n  const onClick = (e, cell) => {\n    setEditing(cell);\n  };\n\n  const rowLabelsGen = letterLabelGenerator();\n\n  return (\n    <div className={style.Spreadsheet}>\n      <table>\n        <thead>\n        <tr>\n          <th/>\n          {Array(props.x).fill(0).map((_, i) =>\n            <th key={i}>\n              {rowLabelsGen.next().value}\n            </th>\n          )}\n        </tr>\n        </thead>\n        <tbody>\n        {props.cells.map((row, i) =>\n          <tr key={i}>\n            <th>{i + 1}</th>\n            {row.map((cell, j) =>\n              <td\n                onClick={e => onClick(e, cell)}\n                key={j}>\n                {isEditing(cell) ?\n                  <input\n                    onKeyDown={onInputKeyDown}\n                    onFocus={e => onFocus(e, cell)}\n                    onBlur={e => onBlur(e, cell)}\n                    autoFocus={true}\n                  /> :\n                  <div\n                    className={cell.error? style.error : \"\"}\n                  >\n                    {cell.error? cell.error : cell.value}\n                  </div>\n                }\n              </td>\n            )}\n          </tr>\n        )}\n        </tbody>\n      </table>\n    </div>\n  );\n};\n\n\nfunction useEditing(initial) {\n\n  let [editing, _setEditing] = useState(initial);\n\n  const setEditing = (cell) => {\n    if (cell == null) {\n      _setEditing(null)\n    }\n    else {\n      _setEditing({x: cell.x, y: cell.y})\n    }\n  };\n\n  const isEditing = (cell) => {\n    return editing && editing.x === cell.x && editing.y === cell.y;\n  };\n\n  return [isEditing, setEditing];\n}\n\n\nSpreadsheet.propTypes = {\n  cells: PropTypes.arrayOf(PropTypes.array).isRequired,\n  onCellSet: PropTypes.func.isRequired,\n  x: PropTypes.number.isRequired,\n  y: PropTypes.number.isRequired,\n};\n\nexport default observer(Spreadsheet);\n","import {observable} from \"mobx\";\nconst Parser = require(\"../parser/parser\").Parser;\n\nexport class Cell {\n\n  @observable formula = null;\n  @observable value = null;\n  @observable error = null;\n\n  constructor(sheet, x, y) {\n    this.sheet = sheet;\n    this.x = x;\n    this.y = y;\n  }\n\n  // cells that observe ass -> we are used in their formula\n  observers = [];\n  // cells that we observe for changes -> we use them in our formula\n  // this is needed to remove us from their observer list when we change formula\n  // could avoid this list by parsing old formula for cell one more time\n  // dunno which is better\n  subjects = [];\n\n  set(string) {\n    this.unregisterFromAllSubjects();\n    try {\n      if (isFormula(string)) {\n        this.formula = string;\n\n        const parser = new Parser(this.sheet.getCellByLabel.bind(this.sheet));\n        parser.feed(this.formula.substring(1));\n        this.value = parser.results;\n        const cellsReferenced = parser.cellsReferenced;\n        for (const cell of cellsReferenced) {\n          this.observe(cell);\n        }\n      } else {\n        const x = parseFloat(string);\n        if (!isNaN(x)) {\n          this.value = x;\n        }\n        else {\n          this.value = string;\n        }\n        this.formula = null;\n      }\n\n      const x = this.topologicalSort();\n      for (const cell of x) {\n        cell.calculateValue();\n      }\n      this.error = null;\n    } catch (e) {\n      this.error = e.message;\n    }\n\n\n  }\n\n  unregisterFromAllSubjects() {\n    for (const cell of this.subjects) {\n      cell.unregisterObserver(this);\n    }\n    this.subjects = [];\n  }\n\n  observe(cell) {\n    cell.registerObserver(this);\n    this.subjects.push(cell);\n  }\n\n  topologicalSort() {\n    let visited = [];\n    let sorted = [];\n    dfs(this);\n\n    function dfs(cell) {\n      if (sorted.includes(cell)) {\n        return;\n      }\n      if (visited.includes(cell)) {\n        throw Error(\"cycle\");\n      }\n      visited.push(cell);\n      for (const neighbour of cell.observers) {\n        dfs(neighbour)\n      }\n      sorted.push(cell);\n    }\n\n    return sorted.reverse().slice(1);\n  }\n\n  registerObserver(cell) {\n    this.observers.push(cell);\n  }\n\n  unregisterObserver(cell) {\n    const index = this.observers.indexOf(cell);\n    if (index === this.observers.length - 1) {\n      this.observers.pop();\n    } else {\n      this.observers[index] = this.observers.pop();\n    }\n  }\n\n  calculateValue() {\n    const parser = new Parser(this.sheet.getCellByLabel.bind(this.sheet));\n    parser.feed(this.formula.substring(1));\n    this.value = parser.results;\n  }\n\n}\n\n\nexport class SpreadsheetStore {\n  cells = [];\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n    this.cells = Array(y);\n    for (let i = 0; i < y; i++) {\n      this.cells[i] = Array(x);\n      for (let j = 0; j < x; j++) {\n        this.cells[i][j] = new Cell(this, i, j);\n      }\n    }\n  }\n\n  /**\n   * @param cellLabel For example: A2, AB13, C13 etc as string\n   */\n  getCellByLabel(cellLabel) {\n    cellLabel = cellLabel.toUpperCase();\n    let index = 0;\n    while (index < cellLabel.length && isUpperLetter(cellLabel[index])) {\n      index++;\n    }\n    const letters = cellLabel.substring(0, index);\n    const digits = cellLabel.substring(index);\n\n    if (letters.length === 0 || digits.length === 0) {\n      throw Error(`Incorrect label: ${cellLabel}`)\n\n    }\n\n    const y_index = parseInt(digits) - 1;\n\n    let x_index = 0;\n    for (let i = 0; i < letters.length; i++) {\n      x_index *= (\"Z\".charCodeAt(0) - 'A'.charCodeAt(0) + 1);\n      x_index += letters[i].charCodeAt(0) - \"A\".charCodeAt(0);\n    }\n\n    if (this.x <= x_index || this.y <= y_index) {\n      throw Error(`No cell: ${cellLabel}`)\n    }\n    return this.cells[y_index][x_index];\n  }\n}\n\n\n// helper functions\n\nfunction isFormula(x) {\n  return x.charAt(0) === '=';\n}\n\nfunction isUpperLetter(x) {\n  return 'A'.charCodeAt(0) <= x.charCodeAt(0) && x.charCodeAt(0) <= 'Z'.charCodeAt(0);\n}\n","/* eslint-disable */\nimport './grammar.js'\nconst nearley = require('nearley');\nconst postProcessors = require('./parserPostProcessors.js').postProcessors;\n\n\n\nexport class Parser {\n  cellsReferenced = [];\n  constructor(getByLabel) {\n    console.log(grammar)\n    this.parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));\n\n    // to understand it read comment in parserPostProcessors.js\n    postProcessors.getByLabel = (label) => {\n      const cell = getByLabel(label);\n      this.cellsReferenced.push(cell);\n      return cell.value;\n    };\n\n    const debug = false;\n    postProcessors.log = debug ? (function () {\n      console.log(...arguments)\n    }) : () => {};\n  }\n\n  feed(s) {\n    return this.parser.feed(s);\n  }\n\n  get results() {\n    return this.parser.results[0][0];\n  }\n}\n","// Generated automatically by nearley, version 2.19.1\n// http://github.com/Hardmath123/nearley\n(function () {\nfunction id(x) { return x[0]; }\n\n  /* eslint-disable */\n\n  const moo = require(\"moo\");\n  const tokens = require('./tokens.js')\n  const post = require(\"./parserPostProcessors.js\").postProcessors\n\n  const lexer = moo.states(tokens);\n  // ignore whitespaces tokens\n  lexer.next = (next => () => {\n      let tok;\n      while ((tok = next.call(lexer)) && tok.type === \"whitespace\") {}\n      return tok;\n  })(lexer.next);\n\nvar grammar = {\n    Lexer: lexer,\n    ParserRules: [\n    {\"name\": \"input\", \"symbols\": [\"expression\"]},\n    {\"name\": \"expression\", \"symbols\": [\"multi_expr\"], \"postprocess\": \n        ([a]) => {\n          post.log(\"expression\")\n          post.log(\"a:\", a);\n          return a;\n         }\n          },\n    {\"name\": \"expression\", \"symbols\": [\"expression\", (lexer.has(\"plus\") ? {type: \"plus\"} : plus), \"multi_expr\"], \"postprocess\": \n        ([a,_,b]) => {\n          post.log(\"expression\")\n          post.log(\"a:\", a)\n          post.log(\"b:\", b)\n          return a+b;\n         }\n            },\n    {\"name\": \"expression\", \"symbols\": [\"expression\", (lexer.has(\"minus\") ? {type: \"minus\"} : minus), \"multi_expr\"], \"postprocess\": \n        ([a,_,b]) => {\n          post.log(\"expression\")\n          post.log(\"a:\", a)\n          post.log(\"b:\", b)\n          return a-b;\n         }\n            },\n    {\"name\": \"multi_expr\", \"symbols\": [\"primary\"], \"postprocess\": \n        ([a]) => {\n          post.log(\"multi_expr\")\n          post.log(\"a:\", a);\n          return a;\n         }\n            },\n    {\"name\": \"multi_expr\", \"symbols\": [\"multi_expr\", (lexer.has(\"asterisk\") ? {type: \"asterisk\"} : asterisk), \"primary\"], \"postprocess\": \n        ([a,_,b]) => {\n          post.log(\"multi_expr\")\n          post.log(\"a:\", a)\n          post.log(\"b:\", b)\n          return a*b;\n         }\n            },\n    {\"name\": \"multi_expr\", \"symbols\": [\"multi_expr\", (lexer.has(\"slash\") ? {type: \"slash\"} : slash), \"primary\"], \"postprocess\": \n        ([a,_,b]) => {\n          post.log(\"multi_expr\")\n          post.log(\"a:\", a)\n          post.log(\"b:\", b)\n          return a/b;\n         }\n            },\n    {\"name\": \"primary\", \"symbols\": [(lexer.has(\"lparen\") ? {type: \"lparen\"} : lparen), \"expression\", (lexer.has(\"rparen\") ? {type: \"rparen\"} : rparen)], \"postprocess\": \n        (data) => { return data[1]; }\n            },\n    {\"name\": \"primary\", \"symbols\": [(lexer.has(\"number\") ? {type: \"number\"} : number)], \"postprocess\": \n        ([number]) => {\n          post.log(\"number:\", number.value);\n          return number.value;\n        }\n          },\n    {\"name\": \"primary\", \"symbols\": [(lexer.has(\"minus\") ? {type: \"minus\"} : minus), (lexer.has(\"number\") ? {type: \"number\"} : number)], \"postprocess\": \n        ([_,number]) => {\n          post.log(\"number:\", number.value);\n          return -number.value;\n        }\n          },\n    {\"name\": \"primary\", \"symbols\": [\"cell_ref\"], \"postprocess\": id},\n    {\"name\": \"primary\", \"symbols\": [\"func\"], \"postprocess\": \n        ([func]) => {\n          post.log(\"func:\", func)\n          return func;\n        }\n            },\n    {\"name\": \"cell_ref\", \"symbols\": [(lexer.has(\"label\") ? {type: \"label\"} : label)], \"postprocess\": \n        ([label]) => {\n          post.log(\"label:\", label.value)\n          return  post.getByLabel(label.value);\n        }\n          },\n    {\"name\": \"func\", \"symbols\": [(lexer.has(\"func_call\") ? {type: \"func_call\"} : func_call), \"args\", (lexer.has(\"func_call_end\") ? {type: \"func_call_end\"} : func_call_end)], \"postprocess\": \n        ([func_name, args]) => {\n          // todo call function smth like: global[func_name.value](...args)\n          post.log(\"func_name:\", func_name.value)\n          post.log(\"args:\", args)\n          let sum = 0;\n          for (const x of args){\n            sum += x;\n          }\n          return sum;\n        }\n            },\n    {\"name\": \"args\", \"symbols\": [\"range\"], \"postprocess\": \n        ([range]) => {\n          post.log(\"range:\", range)\n          return range;\n        }\n            },\n    {\"name\": \"args\", \"symbols\": [\"list\"], \"postprocess\": \n        ([list]) => {\n          post.log(\"list(args):\", list)\n          return list;\n        }\n            },\n    {\"name\": \"range\", \"symbols\": [(lexer.has(\"label\") ? {type: \"label\"} : label), (lexer.has(\"colon\") ? {type: \"colon\"} : colon), (lexer.has(\"label\") ? {type: \"label\"} : label)], \"postprocess\": \n        ([label1, _, label2]) => {\n          // todo get values for range label1:label2\n          post.log(\"label1:\", label1.value)\n          post.log(\"label2:\", label2.value)\n          return [label1.value,\":\",label2.value];\n        }\n            },\n    {\"name\": \"list\", \"symbols\": [(lexer.has(\"label\") ? {type: \"label\"} : label)], \"postprocess\": \n        ([label]) => {\n          post.getByLabel(label.value)\n          post.log(\"label(list):\", label.value)\n          return  [post.getByLabel(label.value)];\n        }\n            },\n    {\"name\": \"list\", \"symbols\": [(lexer.has(\"label\") ? {type: \"label\"} : label), (lexer.has(\"semicolon\") ? {type: \"semicolon\"} : semicolon), \"list\"], \"postprocess\": \n        ([label, _, list]) => {\n          post.getByLabel(label.value)\n          post.log(\"label(label ; list):\", label.value)\n          post.log(\"list(label ; list):\", list)\n          list.push(post.getByLabel(label.value));\n          return list;\n        }\n            }\n]\n  , ParserStart: \"input\"\n}\nif (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {\n   module.exports = grammar;\n} else {\n   window.grammar = grammar;\n}\n})();\n","// tokenizer has two states: main and func_args\nmodule.exports = {\n  main:{\n    whitespace: { match: /[\\s]+/, lineBreaks: true },\n    func_call:  {\n      match: /[a-zA-Z_$][0-9a-zA-Z_$]*\\(/,\n      push: 'func_args', // change to func_args state\n      value: x => x.slice(0, -1), // remove last character\n    },\n    label: /[a-zA-Z]+[1-9]+[0-9]*/,\n    plus: '+',\n    asterisk: '*',\n    slash: '/',\n    minus: '-',\n    lparen: '(',\n    rparen: ')',\n    number: {\n      match: /[1-9][0-9]*(?:,[0-9]*)?|0\\.[0-9]+/, // examples : 0 | 0,123 | -14 | +0,23\n      value: x=> parseFloat(x),\n    },\n  },\n  func_args:{\n    func_call_end:  {match: ')', pop: 1}, // come back to main state\n    label: /[a-zA-Z]+[1-9]+[0-9]*/,\n    semicolon: ';',\n    colon: ':',\n    whitespace: /[ ]+/,\n  }\n};\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.0/8 are considered localhost for IPv4.\n  window.location.hostname.match(\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n  )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n            'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: {'Service-Worker': 'script'}\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App/>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}