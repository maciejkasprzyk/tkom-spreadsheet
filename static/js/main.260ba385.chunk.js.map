{"version":3,"sources":["components/Spreadsheet.module.scss","components/Editor.module.scss","parser/indentedLexer.js","components/App.module.scss","utils.js","components/Spreadsheet.js","nodes/BaseNode.js","nodes/BinaryOperationNode.js","nodes/AdditionNode.js","nodes/SubtractionNode.js","nodes/MultiplicationNode.js","nodes/DivisionNode.js","nodes/NumberNode.js","nodes/NegativeNode.js","nodes/UnaryOperator.js","nodes/FunctionCallNode.js","nodes/VariableNode.js","nodes/RangeNode.js","nodes/CellNode.js","nodes/DynamicCellNode.js","nodes/AssignmentNode.js","nodes/WhileNode.js","nodes/IfElseNode.js","nodes/EqualNode.js","nodes/GreaterEqualNode.js","nodes/LessEqualNode.js","nodes/LessNode.js","nodes/GreaterNode.js","nodes/NotEqualNode.js","nodes/FunctionDefNode.js","nodes/ReferenceNode.js","nodes/ReturnNode.js","parser/parserPostProcessors.js","parser/lexer.js","parser/grammar.js","parser/formulaGrammar.js","parser/parsers.js","environment/Variable.js","environment/Cell.js","environment/Environment.js","mobx/SpreadsheetStore.js","components/Editor.js","components/App.js","serviceWorker.js","index.js","parser/errors.js"],"names":["module","exports","IndentedLexer","lexer","ws","end","this","startsWith","str","prefix","lastIndexOf","unicodeDebugString","s","u","i","length","n","charCodeAt","hex16","j","d","offset","String","fromCharCode","prototype","next","ignoreWhiteSpaceNext","e","require","UserError","message","tok","indentedNext","type","tokens","generateMoreTokens","shift","token","changeIndent","push","afterNewLine","value","col","line","indent","indents","prev","text","lineBreaks","Error","pop","save","reset","data","info","formatError","has","name","window","letterLabelGenerator","nextChar","c","label","slice","reverse","join","index","getCellIndexes","cellIdentifier","match","exec","divideIntoLettersAndNumber","letters","digits","y_index","parseInt","x_index","x","y","errorInfoExecDecorator","target","descriptor","original","args","apply","observer","props","initial","useState","editing","_setEditing","cell","useEditing","isEditing","setEditing","onInputKeyDown","keyCode","blur","rowLabelsGen","className","style","Spreadsheet","Array","fill","map","_","key","cells","row","backgroundColor","background","onClick","onKeyDown","onFocus","formula","parentNode","classList","add","focus","onBlur","onCellSet","remove","autoFocus","error","BaseNode","env","property","concat","findCellsReferenced","BinaryOperationNode","left","right","unParse","AdditionNode","SubtractionNode","MultiplicationNode","DivisionNode","NumberNode","NegativeNode","operand","FunctionCallNode","identifier","func","getFunction","argsValues","a","newScope","setVariable","block","b","result","popScope","VariableNode","getReference","undefined","getVarByName","RangeNode","startCell","endCell","cell1","cell2","getCellsByRange","CellNode","getCell","DynamicCellNode","AssignmentNode","ast","cloneDeep","wrapper","replaceVariablesWithConstants","varValue","toString","setCell","WhileNode","condition","ifElseNode","elseBlock","EqualNode","environ","GreaterEqualNode","LessEqualNode","LessNode","GreaterNode","NotEqualNode","FunctionDefNode","setFunction","ReferenceNode","referenced","setReference","ReturnNode","expr","returnHandler","addition","subtraction","multiplication","division","number","negative","functionCall","equal","greaterEqual","lessEqual","less","greater","notEqual","variable","range","assigment","emptyList","dynamicCell","reference","argsList","first","list","el","moo","ampersand","dot","comma","lparen","rparen","lsquare","rsquare","plus","asterisk","slash","minus","semicolon","colon","assign","string","parseFloat","id","Lexer","ParserRules","p","kwIf","kwWhile","kwDef","kwElse","dedent","kwReturn","ParserStart","Parser","parser","nearley","fromCompiled","grammar","feed","results","FormulaParser","formulaGrammar","Variable","Cell","observers","subjects","_unregisterObserver","v","indexOf","observable","Environment","funcitons","gen","variablesScopes","referencesScopes","unregisterFromAllSubjects","charAt","isFormula","_setCellFormula","_setCellValue","_updateObservers","substring","varsReferenced","observe","isNaN","start","x1","y1","x2","y2","startVariable","visited","sorted","dfs","includes","neighbour","topologicalSort","variables","hasOwnProperty","node","SpreadsheetStore","code","annotations","m","lines","split","Math","min","column","console","log","setCodeState","setCode","Editor","Top","customFileUpload","onChange","file","files","fr","FileReader","addEventListener","o","JSON","parse","onSubmit","onLoad","readAsText","onSave","mode","theme","height","width","store","Bottom","onLogParseTree","onLogLexerOutput","App","indexes","cellsToObjects","blob","Blob","stringify","saveAs","run","logLexerOutput","logParseTree","Boolean","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","returnMessage","params","captureStackTrace"],"mappings":"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","file":"static/js/main.260ba385.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"Spreadsheet\":\"Spreadsheet_Spreadsheet__2MlAU\",\"focus\":\"Spreadsheet_focus__2PRei\",\"error\":\"Spreadsheet_error__2OBGk\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"Editor\":\"Editor_Editor__3K0No\",\"Top\":\"Editor_Top__3e9Hb\",\"customFileUpload\":\"Editor_customFileUpload__SpF0p\",\"Bottom\":\"Editor_Bottom__MdgSJ\"};","(function () {\n\n  function IndentedLexer(lexer, ws, end) {\n    this.lexer = lexer;\n    this.ws = ws; // white space token\n    this.end = end; // new line token\n  }\n\n  IndentedLexer.prototype.next = function () {\n    try {\n      return this.ignoreWhiteSpaceNext();\n    } catch (e) {\n      const errors = require('./errors')\n      throw new errors.UserError(e.message);\n    }\n  }\n\n  IndentedLexer.prototype.ignoreWhiteSpaceNext = function () {\n    let tok;\n    while ((tok = this.indentedNext()) && tok.type === this.ws) {\n    }\n    return tok;\n  }\n\n  IndentedLexer.prototype.indentedNext = function () {\n    while (this.tokens.length === 0) {\n      this.generateMoreTokens();\n    }\n    return this.tokens.shift()\n  }\n\n  IndentedLexer.prototype.generateMoreTokens = function () {\n    let token = this.lexer.next(this);\n    if (!token) {\n      this.changeIndent(\"\");\n      this.tokens.push(token);\n      return;\n    }\n\n    if (this.afterNewLine) {\n      this.afterNewLine = false;\n      if (token.type === this.ws) {\n        this.changeIndent(token.value, token.col, token.line, token.offset);\n      } else {\n        this.changeIndent(\"\", token.col, token.line, token.offset);\n        this.tokens.push(token);\n      }\n    } else {\n      this.tokens.push(token);\n    }\n    this.afterNewLine = (token.type === this.end);\n  };\n\n  IndentedLexer.prototype.changeIndent = function (indent, col, line, offset) {\n    while (indent !== this.indents[this.indents.length - 1]) {\n      let prev = this.indents[this.indents.length - 1];\n      if (startsWith(indent, prev)) {  // more indentation than we had.\n        this.tokens.push({\n          type: 'indent',\n          text: indent,\n          value: indent,\n          lineBreaks: 0,\n          col: col,\n          line: line,\n          offset: offset,\n        });\n        this.indents.push(indent);\n        return;\n      } else if (startsWith(prev, indent)) { // less indentation than we had.\n        this.tokens.push({\n          type: 'dedent',\n          text: indent,\n          value: indent,\n          lineBreaks: 0,\n          col: col,\n          line: line,\n          offset: offset,\n        });\n        this.indents.pop();  // check the previous one.\n      } else {\n        prev = unicodeDebugString(prev);\n        indent = unicodeDebugString(indent);\n        throw Error('Indentations cannot be compared: ' + prev + ' and ' + indent + '.');\n      }\n    }\n  }\n\n  IndentedLexer.prototype.save = function () {\n    return this.lexer.save();\n  }\n\n  IndentedLexer.prototype.reset = function (data, info) {\n    this.lexer.reset(data, info);\n    this.indents = [''];\n    this.tokens = [];\n    this.afterNewLine = true;\n  }\n\n  IndentedLexer.prototype.formatError = function (token) {\n    return this.lexer.formatError(token, \"Invalid syntax\");\n  }\n\n  IndentedLexer.prototype.has = function (name) {\n    return this.lexer.has(name);\n  }\n\n  // ---------------------------------------------------------\n\n  function startsWith(str, prefix) {\n    return str.lastIndexOf(prefix, 0) === 0;\n  }\n\n  function unicodeDebugString(s) {\n    let u = '';\n    for (let i = 0; i < s.length; ++i) {\n      let n = s.charCodeAt(i), hex16 = '';\n      for (let j = 0; j < 4; ++j) {\n        let d = n % 16;\n        n /= 16;\n        let offset = (d < 10) ? 0x30 : 0x61 - 10\n        let ch = String.fromCharCode(d + offset);\n        hex16 = ch + hex16;\n      }\n      u += ('\\\\u' + hex16);\n    }\n    return '\"' + u + '\"';\n  }\n\n  // ---------------------------------------------------------\n\n  if (typeof module === 'object' && module.exports) {\n    module.exports = IndentedLexer;\n  } else {\n    window.IndentedLexer = IndentedLexer;\n  }\n})();\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"App\":\"App_App__rq8wc\"};","import {UserError} from \"./parser/errors\";\n\n/**\n * It returns strings like this: \"A\", \"B\", ... , \"Z\", \"AA\", \"AB\", ...\n */\nexport function* letterLabelGenerator() {\n  function nextChar(c) {\n    return String.fromCharCode(c.charCodeAt(0) + 1);\n  }\n\n  const label = ['A'];\n  while (true) {\n    yield label.slice().reverse().join(\"\");\n    let index = 0;\n    label[index] = nextChar(label[index]);\n    while (label[index].charCodeAt(0) > 'Z'.charCodeAt(0)) {\n      label[index] = 'A';\n      index++;\n      if (index >= label.length) {\n        label.push('A');\n        break;\n      }\n      label[index] = nextChar(label[index]);\n    }\n  }\n}\n\n\nexport function topologicalSort(startVariable) {\n  let visited = [];\n  let sorted = [];\n  dfs(startVariable);\n\n  function dfs(variable) {\n    if (sorted.includes(variable)) {\n      return;\n    }\n    if (visited.includes(variable)) {\n      throw new UserError(\"Cycle\");\n    }\n    visited.push(variable);\n    for (const neighbour of variable.observers) {\n      dfs(neighbour)\n    }\n    sorted.push(variable);\n  }\n\n  return sorted.reverse().slice(1);\n}\n\nexport function isFormula(x) {\n  return x.charAt(0) === '=';\n}\n\nfunction divideIntoLettersAndNumber(cellIdentifier) {\n  const regex = /([a-zA-Z]+)([0-9]+)/;\n  const match = regex.exec(cellIdentifier);\n\n  return [match[1], match[2]];\n}\n\nexport function getCellIndexes(cellIdentifier) {\n  const [letters, digits] = divideIntoLettersAndNumber(cellIdentifier);\n\n  const y_index = parseInt(digits) - 1;\n\n  let x_index = -1;\n  for (let i = 0; i < letters.length; i++) {\n    x_index += 1\n    x_index *= (\"Z\".charCodeAt(0) - 'A'.charCodeAt(0) + 1);\n    x_index += letters[i].charCodeAt(0) - \"A\".charCodeAt(0);\n  }\n  return {x: x_index, y: y_index}\n}\n\nexport function errorInfoExecDecorator(target, name, descriptor) {\n  const original = descriptor.value;\n  if (typeof original === 'function') {\n    descriptor.value = function (...args) {\n      try {\n        return original.apply(this, args)\n      } catch (e) {\n        if (e.name === \"UserError\") {\n          e.message = 'Execution error at line ' + this.line + ' col ' + this.col + ':\\n' + e.message;\n          throw e;\n        } else {\n          throw e;\n        }\n      }\n    }\n  }\n  return descriptor\n}\n","import React, {useState} from 'react';\nimport {observer} from \"mobx-react\";\nimport style from './Spreadsheet.module.scss'\nimport PropTypes from 'prop-types'\nimport {letterLabelGenerator} from \"../utils\";\n\n\n\nconst Spreadsheet = props => {\n\n  let [isEditing, setEditing] = useEditing();\n\n\n  const onInputKeyDown = (e) => {\n    if (e.keyCode === 13) {\n      e.target.blur();\n    }\n  };\n\n  const onBlur = (e, cell) => {\n    props.onCellSet(cell.x, cell.y, e.target.value);\n    e.target.parentNode.classList.remove(style.focus);\n    if (isEditing(cell)){\n      setEditing(null);\n    }\n  };\n\n  const onFocus = (e, cell) => {\n    e.target.value = cell.formula ? cell.formula : cell.value;\n    e.target.parentNode.classList.add(style.focus)\n  };\n\n  const onClick = (e, cell) => {\n    setEditing(cell);\n  };\n\n  const rowLabelsGen = letterLabelGenerator();\n\n  return (\n    <div className={style.Spreadsheet}>\n      <table>\n        <thead>\n        <tr>\n          <th/>\n          {Array(props.x).fill(0).map((_, i) =>\n            <th key={i}>\n              {rowLabelsGen.next().value}\n            </th>\n          )}\n        </tr>\n        </thead>\n        <tbody>\n        {props.cells.map((row, i) =>\n          <tr key={i}>\n            <th>{i + 1}</th>\n            {row.map((cell, j) =>\n              <td\n                style={{backgroundColor: cell.background}}\n                onClick={e => onClick(e, cell)}\n                key={j}>\n                {isEditing(cell) ?\n                  <input\n                    onKeyDown={onInputKeyDown}\n                    onFocus={e => onFocus(e, cell)}\n                    onBlur={e => onBlur(e, cell)}\n                    autoFocus={true}\n                  /> :\n                  <div\n                    className={cell.error ? style.error : \"\"}\n                  >\n                    {cell.error ? cell.error : cell.value}\n                  </div>\n                }\n              </td>\n            )}\n          </tr>\n        )}\n        </tbody>\n      </table>\n    </div>\n  );\n};\n\n\nfunction useEditing(initial) {\n\n  let [editing, _setEditing] = useState(initial);\n\n  const setEditing = (cell) => {\n    if (cell == null) {\n      _setEditing(null)\n    }\n    else {\n      _setEditing({x: cell.x, y: cell.y})\n    }\n  };\n\n  const isEditing = (cell) => {\n    return editing && editing.x === cell.x && editing.y === cell.y;\n  };\n\n  return [isEditing, setEditing];\n}\n\n\nSpreadsheet.propTypes = {\n  cells: PropTypes.arrayOf(PropTypes.array).isRequired,\n  onCellSet: PropTypes.func.isRequired,\n  x: PropTypes.number.isRequired,\n  y: PropTypes.number.isRequired,\n};\n\nexport default observer(Spreadsheet);\n","export class BaseNode {\n  constructor({value,type,text,offset,line,col}) {\n    this.value = value;\n    this.type = type;\n    this.text = text;\n    this.offset  = offset\n    this.line = line;\n    this.col = col;\n  }\n\n  findCellsReferenced(env) {\n    let cells = []\n    for (let property in this) {\n      if (this[property] instanceof BaseNode) {\n        cells = cells.concat(this[property].findCellsReferenced(env));\n      }\n    }\n    return cells;\n  }\n\n\n  unParse(env) {\n    return this.text;\n  }\n}\n","import {BaseNode} from \"./BaseNode\";\n\nexport class BinaryOperationNode extends BaseNode {\n  constructor(left,right, token) {\n    super(token);\n    this.left = left;\n    this.right = right;\n  }\n\n\n  unParse(env) {\n    return '( ' + this.left.unParse(env) + \" \" +  this.text + \" \" + this.right.unParse(env) + ' )';\n  }\n\n}\n","import {BinaryOperationNode} from \"./BinaryOperationNode\";\n\nexport class AdditionNode extends BinaryOperationNode {\n\n  exec(env) {\n    return this.left.exec(env) + this.right.exec(env);\n  }\n}\n","import {BinaryOperationNode} from \"./BinaryOperationNode\";\n\nexport class SubtractionNode extends BinaryOperationNode {\n\n  exec(env) {\n    return this.left.exec(env) - this.right.exec(env);\n  }\n}\n","import {BinaryOperationNode} from \"./BinaryOperationNode\";\n\nexport class MultiplicationNode extends BinaryOperationNode {\n  exec(env) {\n    return this.left.exec(env) * this.right.exec(env);\n  }\n}\n","import {BinaryOperationNode} from \"./BinaryOperationNode\";\n\nexport class DivisionNode extends BinaryOperationNode {\n  exec(env) {\n    return this.left.exec(env) / this.right.exec(env);\n  }\n}\n","import {BaseNode} from \"./BaseNode\";\n\nexport class NumberNode extends BaseNode {\n  exec() {\n    return this.value;\n  }\n}\n","import {UnaryOperator} from \"./UnaryOperator\";\n\nexport class NegativeNode extends UnaryOperator {\n  exec(env) {\n    return -this.operand.exec(env);\n  }\n}\n","import {BaseNode} from \"./BaseNode\";\n\nexport class UnaryOperator extends BaseNode {\n  constructor(operand, token) {\n    super(token);\n    this.operand = operand;\n  }\n}\n","import {UserError} from \"../parser/errors\";\nimport {BaseNode} from \"./BaseNode\";\n\nexport class FunctionCallNode extends BaseNode {\n  constructor(identifier, args, token) {\n    super(token);\n    this.identifier = identifier;\n    this.args = args;\n  }\n\n  exec(env) {\n    const func = env.getFunction(this.identifier.value);\n\n    if (this.args.length !== func.args.length) {\n      throw new UserError(`${func.args.length} params function called with ${this.args.length} params.`);\n    }\n\n    const argsValues = [];\n    for (const a of this.args) {\n      argsValues.push(a.exec(env));\n    }\n\n    env.newScope();\n    for (let i = 0; i < this.args.length; i++) {\n      env.setVariable(func.args[i].identifier, argsValues[i]);\n    }\n\n    for (const b of func.block) {\n      try {\n        b.exec(env);\n      } catch (e) {\n        if (e.name === 'returnHandler') {\n          return e.result;\n        } else {\n          throw e;\n        }\n      }\n    }\n\n    env.popScope();\n    return undefined\n  }\n\n  unParse(env) {\n    const args = [];\n    for (const a of this.args) {\n      args.push(a.unParse());\n    }\n    return this.identifier.value + '(' + args.join(',') + ')'\n  }\n\n  findCellsReferenced(env) {\n    let cells = []\n    for (let a of this.args) {\n      cells = cells.concat(a.findCellsReferenced(env));\n    }\n    return cells;\n  }\n}\n","import {BaseNode} from \"./BaseNode\";\nimport {errorInfoExecDecorator} from \"../utils\";\n\nexport class VariableNode extends BaseNode {\n\n  constructor(identifier, token) {\n    super(token);\n    this.identifier = identifier;\n  }\n\n  @errorInfoExecDecorator\n  exec(env) {\n    const x = env.getReference(this.identifier);\n    if (x !== undefined) {\n      return x.exec(env)\n    }\n    return env.getVarByName(this.identifier).value;\n  }\n}\n","import {BaseNode} from \"./BaseNode\";\n\nexport class RangeNode extends BaseNode {\n  constructor(startCell, endCell, token) {\n    super(token);\n    this.cell1 = startCell;\n    this.cell2 = endCell;\n  }\n\n  exec(env) {\n    // return env.getCellsByRange(this.cell1,this.cell2).map(x=>x.value);\n  }\n\n  findCellsReferenced(env) {\n    return env.getCellsByRange(this.cell1, this.cell2);\n  }\n\n}\n","import {BaseNode} from \"./BaseNode\";\nimport {errorInfoExecDecorator} from \"../utils\";\n\nexport class CellNode extends BaseNode {\n\n  constructor(x,y,token) {\n    super(token);\n    this.x = x;\n    this.y = y;\n  }\n\n  @errorInfoExecDecorator\n  exec(env) {\n    return env.getCell(this.x, this.y).value;\n  }\n\n  findCellsReferenced(env) {\n    return [env.getCell(this.x, this.y)];\n  }\n}\n","import {BaseNode} from \"./BaseNode\";\nimport {errorInfoExecDecorator} from \"../utils\";\n\nexport class DynamicCellNode extends BaseNode {\n\n  constructor(x,y, token) {\n    super(token);\n    this.x = x;\n    this.y = y;\n  }\n\n  @errorInfoExecDecorator\n  exec(env) {\n    const x = this.x.exec(env);\n    const y = this.y.exec(env);\n    return env.getCell(x, y).value;\n  }\n\n  unParse(env) {\n    const x = this.x.exec(env);\n    const y = this.y.exec(env);\n    return env.getCell(x, y).label;\n  }\n}\n","import {BinaryOperationNode} from \"./BinaryOperationNode\";\nimport {UserError} from \"../parser/errors\";\nimport {VariableNode} from \"./VariableNode\";\nimport {CellNode} from \"./CellNode\";\nimport {NumberNode} from \"./NumberNode\";\nimport {BaseNode} from \"./BaseNode\";\nimport _ from 'lodash';\nimport {DynamicCellNode} from \"./DynamicCellNode\";\nimport {errorInfoExecDecorator} from \"../utils\";\n\nexport class AssignmentNode extends BinaryOperationNode {\n\n  @errorInfoExecDecorator\n  exec(env) {\n\n    let left = this.left\n    // check if this left is an reference\n    if (left instanceof VariableNode) {\n      // if reference get referenced value\n      const x = env.getReference(left.identifier);\n      if (x !== undefined) {\n        left = x\n      }\n    }\n    if (left instanceof VariableNode) {\n      env.setVariable(left.value, this.right.exec(env));\n    } else if (left instanceof CellNode || left instanceof DynamicCellNode) {\n      let x, y;\n      if (left instanceof CellNode) {\n        x = left.x;\n        y = left.y;\n      } else {\n        x = left.x.exec(env);\n        y = left.y.exec(env);\n      }\n\n      let ast = _.cloneDeep(this.right);\n\n      // hack wrapper to stay DRY\n      const wrapper = {ast: ast};\n      replaceVariablesWithConstants(wrapper, env);\n      ast = wrapper.ast;\n      const formula = \"=\" + ast.unParse(env);\n\n      env.setCell(x, y, formula);\n\n    } else {\n      throw new UserError(\"Assign not to variable\");\n    }\n  }\n}\n\nfunction replaceVariablesWithConstants(ast, env) {\n  for (let property in ast) {\n    if (ast[property] instanceof VariableNode) {\n        const x = env.getReference(ast[property].identifier);\n        if (x !== undefined) {\n          ast[property] = x;\n        }\n      }\n      if (ast[property] instanceof VariableNode) {\n        const varValue = ast[property].exec(env);\n        ast[property] = new NumberNode({value: varValue, text:varValue.toString()});\n      } else if (ast[property] instanceof BaseNode) {\n        replaceVariablesWithConstants(ast[property], env);\n      }\n\n  }\n}\n\n// trudny przypadek\n// i = 5\n// while i < 10\n//    cell[i,0] = i\n//    i += 1\n\n// trzeba w ktoryms momencie dynamicznie zmienic drzewo parsowania, ta zeby wezel zmiennej i zostal zamieniony\n// na wezel typu stałej, o wartoscie zmiennej i w danym momemencie\n// mysle zeby to zrobic w metodzie exec wezla assignment node, przejde po calym ast i podstawie wszystkie wywolania\n// zmiennych\n\n\n// super trudny przypadek\n// mnoznik = 5\n// def fun(komorka):\n//    while mnoznik < 10\n//        mnoznik = mnoznik * 2\n//    return mnoznik * komorka\n// mnoznik = 10\n// A1 = fun(A2)\n// mnoznik = 15\n\n\n// czy wgl pozwalac na funkcje korzystajace ze zmiennych globalnych?\n// jezeli tak to w tym przypadku w wywolaniu funkcj nie wystarczy przechowywac jej identyfikatora,\n// trzeba jakos przechowywac wartosc zmiennych globalnych w momencie rozpoczecia funkcji\n\n// albo (latwiej) nie pozwalac na wykorzystywanie zmiennych globalnych w funkcjach\n\n\n// w konstrukcjach typu cell(A2,A3) = 5*A1  zostanie wykokonane przypisanie do komorki o wspolrzednych,\n// ktore okreslaja A2 oraz A3 w momencie wykonania, pozniejsze zmiany A2 i A3 nie beda mialy wplywy na to przypisanie\n\n\n// ciekawy przypadek\n//\n// wpisze do komorki A1 wartosc rowna 5\n// wykonam kod:\n// zmienna = A1\n// A2 = zmienna\n//\n// wtedy w komorce A2 bede mial wartosc 5\n\n// zwrocmy uwage ze kolejnosc operacji jest tutaj wazna\n// jezeli zrobie na odwrot:\n//\n// wykonam kod:\n// zmienna = A1\n// A2 = zmienna\n// wpisze do komorki A1 wartosc rowna 5\n//\n// to komorka A2 bedzie miala wartosc pusta\n\n\n// jak uzyskac formule z drzewa parsowania?\n// np uzytkownik wpisuje\n//\n// zmienna = 5\n// A1 = A2 * zmienna\n//\n// ja teraz chce zeby po kliniecie komorki A1 w arkuszu wyświetlilo sie:  =A2*5\n// w momencie wywolania przypisania do komorki:\n// 1) przejsc sie po drzewie parsowania i podstawic stale w miejsce odwolan do zmiennych\n// 2) w kazdym nodzie uzywanym w formulaGrammar zaimplementowac metode unparse, ktora pozwoli stoworzyc\n// stringa na podstawie drzewa parsowania\n\n\n// czy w kodzie jest jakis odpowiednik wpisania\n\n\n// jeszcze zastanówmy się nad zapisywanie\n// problematyczne będzie zapisaywanie komorek w postaci kodu ponieważ w komorkach mozna wpisywać wartosc\n// poprzez value a nie poprzez formule. najlatiwej bedzie jezeli arkusz po prostu zapisze oddzielnie\n// w prostej postaci tablic/obiektow JSON i tyle\n// nie bede musial wtedy implementowac przypisaywanie do value w kodzie\n\n\n// musze sie jeszce zastanowic nad wywylywaniem funkcji -> jak przekazywac argumenty a wszczegolnoscio\n// jak rozwiazac problem przekzywania do funkcji rangów? czy pozwalać na zmienna ilosc argumentów?\n// może zrobić to tak fajnie że można przekażać dowolną ilość argumentów a interpreter je wszystkie zbiera\n// (rozpakowuje range) w jedna konstrukcje aka liste. Ta lista jedyne na co pozwala to iterowanie\n// przy iterowaniu moglbym uzyc konstrukcji for cell in args\n// a w poszegolnych obrotach moglbym skorzystac z tego samego sposobu w jaki zaimplementuje alias\n// zeby ustawiac aliasy na kolejne komorki w liscie\n","import {BaseNode} from \"./BaseNode\";\n\nexport class WhileNode extends BaseNode {\n  constructor(condition, block, token) {\n    super(token);\n    this.condition = condition;\n    this.block = block;\n  }\n\n  exec(env) {\n    while (this.condition.exec(env)) {\n      for (const line of this.block) {\n        line.exec(env);\n      }\n    }\n  }\n}\n","import {BaseNode} from \"./BaseNode\";\n\nexport class ifElseNode extends BaseNode {\n  constructor(condition, block, elseBlock, token) {\n    super(token);\n    this.condition = condition;\n    this.block = block;\n    this.elseBlock = elseBlock;\n  }\n\n  exec(env) {\n    debugger\n    if (this.condition.exec(env)) {\n      for (const line of this.block) {\n        line.exec(env);\n      }\n    } else {\n      if (this.elseBlock !== null) {\n        for (const line of this.elseBlock) {\n          line.exec(env);\n        }\n      }\n    }\n  }\n}\n","import {BinaryOperationNode} from \"./BinaryOperationNode\";\n\nexport class EqualNode extends BinaryOperationNode {\n  exec(environ) {\n    return this.left.exec(environ) === this.right.exec(environ);\n  }\n}\n","import {BinaryOperationNode} from \"./BinaryOperationNode\";\n\nexport class GreaterEqualNode extends BinaryOperationNode {\n  exec(env) {\n    return this.left.exec(env) >= this.right.exec(env);\n  }\n}\n","import {BinaryOperationNode} from \"./BinaryOperationNode\";\n\nexport class LessEqualNode extends BinaryOperationNode {\n  exec(env) {\n    return this.left.exec(env) <= this.right.exec(env);\n  }\n}\n","import {BinaryOperationNode} from \"./BinaryOperationNode\";\n\nexport class LessNode extends BinaryOperationNode {\n  exec(env) {\n    return this.left.exec(env) < this.right.exec(env);\n  }\n}\n","import {BinaryOperationNode} from \"./BinaryOperationNode\";\n\nexport class GreaterNode extends BinaryOperationNode {\n  exec(env) {\n    return this.left.exec(env) > this.right.exec(env);\n  }\n}\n","import {BinaryOperationNode} from \"./BinaryOperationNode\";\n\nexport class NotEqualNode extends BinaryOperationNode {\n  exec(env) {\n    return this.left.exec(env) !== this.right.exec(env);\n  }\n}\n","import {BaseNode} from \"./BaseNode\";\n\nexport class FunctionDefNode extends BaseNode{\n  constructor(identifier, args,block, token) {\n    super(token);\n    this.identifier = identifier;\n    this.args = args;\n    this.block = block;\n  }\n\n\n  exec(env) {\n    env.setFunction(this.identifier.value, this.args, this.block);\n  }\n}\n\n\n\n// mozna wywolac funkcje z argumentami pozycyjnymi i wtedy normalnie poszczegolne wartosci sa kopiowane do funkcji\n// 1 argument wywolania do 1 argumentu funkcji itp\n// (maybe) mozna wywolac funkcje podajac przed argumentem *, wszystkie argument z * sa zbierane do jednego argumentu\n// funkcji, ktory tez jest zdefiniowane z * z przodu i mozna po nim iterowac\n","import {BaseNode} from \"./BaseNode\";\n\nexport class ReferenceNode extends BaseNode {\n  constructor(identifier, referenced, token) {\n    super(token);\n    this.identifier = identifier;\n    this.referenced = referenced;\n  }\n\n  exec(env) {\n    env.setReference(this.identifier, this.referenced);\n  }\n}\n","import {BaseNode} from \"./BaseNode\";\nimport {returnHandler} from \"../parser/errors\";\n\nexport class ReturnNode extends BaseNode {\n  constructor(expr, token) {\n    super(token);\n    this.expr = expr\n  }\n\n  exec(env) {\n    throw new returnHandler(this.expr.exec(env));\n  }\n}\n","import {AdditionNode} from \"../nodes/AdditionNode\";\nimport {SubtractionNode} from \"../nodes/SubtractionNode\";\nimport {MultiplicationNode} from \"../nodes/MultiplicationNode\";\nimport {DivisionNode} from \"../nodes/DivisionNode\";\nimport {NumberNode} from \"../nodes/NumberNode\";\nimport {NegativeNode} from \"../nodes/NegativeNode\";\nimport {FunctionCallNode} from \"../nodes/FunctionCallNode\";\nimport {VariableNode} from \"../nodes/VariableNode\";\nimport {RangeNode} from \"../nodes/RangeNode\";\nimport {AssignmentNode} from \"../nodes/AssignmentNode\";\nimport {WhileNode} from \"../nodes/WhileNode\";\nimport {ifElseNode} from \"../nodes/IfElseNode\";\nimport {CellNode} from \"../nodes/CellNode\";\nimport {EqualNode} from \"../nodes/EqualNode\";\nimport {GreaterEqualNode} from \"../nodes/GreaterEqualNode\";\nimport {LessEqualNode} from \"../nodes/LessEqualNode\";\nimport {LessNode} from \"../nodes/LessNode\";\nimport {GreaterNode} from \"../nodes/GreaterNode\";\nimport {NotEqualNode} from \"../nodes/NotEqualNode\";\nimport {FunctionDefNode} from \"../nodes/FunctionDefNode\";\nimport {DynamicCellNode} from \"../nodes/DynamicCellNode\";\nimport {ReferenceNode} from \"../nodes/ReferenceNode\";\nimport {ReturnNode} from \"../nodes/ReturnNode\";\n\nexport function addition([a, token, b]) {\n  return new AdditionNode(a, b, token);\n}\n\nexport function subtraction([a, token, b]) {\n  return new SubtractionNode(a, b, token);\n}\n\nexport function multiplication([a, token, b]) {\n  return new MultiplicationNode(a, b, token);\n\n}\n\nexport function division([a, token, b]) {\n  return new DivisionNode(a, b, token);\n\n}\n\nexport function number([token]) {\n  return new NumberNode(token)\n}\n\nexport function negative([token, operand]) {\n  return new NegativeNode(operand, token);\n}\n\nexport function functionCall([token, _, args]) {\n  return new FunctionCallNode(token.value, args, token);\n}\n\nexport function equal([a, token, b]) {\n  return new EqualNode(a, b, token);\n}\n\nexport function greaterEqual([a, token, b]) {\n  return new GreaterEqualNode(a, b, token);\n}\n\nexport function lessEqual([a, token, b]) {\n  return new LessEqualNode(a, b, token);\n}\n\nexport function less([a, token, b]) {\n  return new LessNode(a, b, token);\n}\n\nexport function greater([a, token, b]) {\n  return new GreaterNode(a, b, token);\n}\n\nexport function notEqual([a, token, b]) {\n  return new NotEqualNode(a, b, token);\n}\n\n\nexport function variable([token]) {\n  return new VariableNode(token.value, token);\n}\n\nexport function range([cell1, token, cell2]) {\n  return new RangeNode(cell1, cell2, token);\n}\n\nexport function list([first, list]) {\n  const result = [first];\n  for (const el of list) {\n    result.push(el[0]);\n  }\n  return result;\n}\n\nexport function assigment([left, token, right]) {\n  return new AssignmentNode(left, right, token);\n}\n\nexport function block([, code]) {\n  return code;\n}\n\nexport function whileLoop([token, expr, , block]) {\n  return new WhileNode(expr, block, token);\n}\n\nexport function ifElse([token, expr, , block, elseBlock]) {\n  if (elseBlock !== null) {\n    elseBlock = elseBlock[0];\n  }\n  return new ifElseNode(expr, block, elseBlock, token);\n}\n\nexport function elseBlock([, , block]) {\n  return block;\n}\n\nexport function emptyList() {\n  return []\n}\n\nexport function cell([token]) {\n  return new CellNode(token.value.x, token.value.y, token);\n}\n\nexport function functionDef([_def, token, _lparen, args, _rparen, _end, block]) {\n  return new FunctionDefNode(token.value, args, block, token)\n}\n\nexport function dynamicCell([_lsquare, x, _semicolon, y, token]) {\n  return new DynamicCellNode(x, y, token);\n}\n\nexport function reference([identifier, _assign, token, referenced]) {\n  return new ReferenceNode(identifier, referenced, token);\n}\n\nexport function returnNode([token, expr]) {\n  return new ReturnNode(expr,token)\n}\n\nexport function argsList([first, list]) {\n  const result = [first];\n  for (const el of list) {\n    result.push(el[1]);\n  }\n  return result;\n}\n","import * as moo from 'moo'\nimport IndentedLexer from './indentedLexer'\nimport {getCellIndexes} from \"../utils\";\n\n\nconst tokens = {\n  ws: /[ \\t\\u00A0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u3000]+/,\n  end: {match: /\\n/, lineBreaks: true},\n  cell: {\n    match: /[a-zA-Z]+[0-9]+/,\n    value: x => getCellIndexes(x),\n  },\n  identifier: {\n    match: /[a-zA-Z]+/,\n    type: moo.keywords({\n      \"kwIf\": \"if\",\n      \"kwWhile\": \"while\",\n      \"kwFor\": \"for\",\n      \"kwElse\": \"else\",\n      \"kwDef\": \"def\",\n      \"kwReturn\": \"return\",\n    })\n  },\n  ampersand: '&',\n  dot: '.',\n  comma: ',',\n  lparen: '(',\n  rparen: ')',\n  lsquare: '[',\n  rsquare: ']',\n  plus: '+',\n  asterisk: '*',\n  slash: '/',\n  minus: '-',\n  semicolon: ';',\n  colon: ':',\n  equal: '==',\n  greaterEqual: '>=',\n  lessEqual: '<=',\n  less: '<',\n  greater: '>',\n  notEqual: '!=',\n  assign: '=',\n  string: /\".*?\"/,\n  number: {\n    match: /[1-9][0-9]*(?:\\.[0-9]*)?|0(?:\\.[0-9]+)?/, // (?: non capturing group\n    value: x => parseFloat(x),\n  },\n\n};\n\nexport const lexer = new IndentedLexer(moo.compile(tokens), 'ws', 'end');\n\n","// Generated automatically by nearley, version 2.19.1\n// http://github.com/Hardmath123/nearley\nfunction id(x) { return x[0]; }\n\n  /* eslint-disable */\n  import * as p from './parserPostProcessors.js'\n  import {lexer} from './lexer.js'\nlet Lexer = lexer;\nlet ParserRules = [\n    {\"name\": \"formulaEntry\", \"symbols\": [\"sum\"]},\n    {\"name\": \"expr\", \"symbols\": [\"comparison\"], \"postprocess\": id},\n    {\"name\": \"comparison\", \"symbols\": [\"sum\"], \"postprocess\": id},\n    {\"name\": \"comparison\", \"symbols\": [\"sum\", (lexer.has(\"equal\") ? {type: \"equal\"} : equal), \"sum\"], \"postprocess\": p.equal},\n    {\"name\": \"comparison\", \"symbols\": [\"sum\", (lexer.has(\"greaterEqual\") ? {type: \"greaterEqual\"} : greaterEqual), \"sum\"], \"postprocess\": p.greaterEqual},\n    {\"name\": \"comparison\", \"symbols\": [\"sum\", (lexer.has(\"lessEqual\") ? {type: \"lessEqual\"} : lessEqual), \"sum\"], \"postprocess\": p.lessEqual},\n    {\"name\": \"comparison\", \"symbols\": [\"sum\", (lexer.has(\"less\") ? {type: \"less\"} : less), \"sum\"], \"postprocess\": p.less},\n    {\"name\": \"comparison\", \"symbols\": [\"sum\", (lexer.has(\"greater\") ? {type: \"greater\"} : greater), \"sum\"], \"postprocess\": p.greater},\n    {\"name\": \"comparison\", \"symbols\": [\"sum\", (lexer.has(\"notEqual\") ? {type: \"notEqual\"} : notEqual), \"sum\"], \"postprocess\": p.notEqual},\n    {\"name\": \"sum\", \"symbols\": [\"product\"], \"postprocess\": id},\n    {\"name\": \"sum\", \"symbols\": [\"sum\", (lexer.has(\"plus\") ? {type: \"plus\"} : plus), \"product\"], \"postprocess\": p.addition},\n    {\"name\": \"sum\", \"symbols\": [\"sum\", (lexer.has(\"minus\") ? {type: \"minus\"} : minus), \"product\"], \"postprocess\": p.subtraction},\n    {\"name\": \"product\", \"symbols\": [\"primary\"], \"postprocess\": id},\n    {\"name\": \"product\", \"symbols\": [\"product\", (lexer.has(\"asterisk\") ? {type: \"asterisk\"} : asterisk), \"primary\"], \"postprocess\": p.multiplication},\n    {\"name\": \"product\", \"symbols\": [\"product\", (lexer.has(\"slash\") ? {type: \"slash\"} : slash), \"primary\"], \"postprocess\": p.division},\n    {\"name\": \"primary\", \"symbols\": [(lexer.has(\"lparen\") ? {type: \"lparen\"} : lparen), \"expr\", (lexer.has(\"rparen\") ? {type: \"rparen\"} : rparen)], \"postprocess\": (data) => data[1]},\n    {\"name\": \"primary\", \"symbols\": [(lexer.has(\"number\") ? {type: \"number\"} : number)], \"postprocess\": p.number},\n    {\"name\": \"primary\", \"symbols\": [\"variable\"], \"postprocess\": id},\n    {\"name\": \"primary\", \"symbols\": [\"function_call\"], \"postprocess\": id},\n    {\"name\": \"primary\", \"symbols\": [\"range\"], \"postprocess\": id},\n    {\"name\": \"primary\", \"symbols\": [\"cell\"], \"postprocess\": id},\n    {\"name\": \"primary\", \"symbols\": [(lexer.has(\"minus\") ? {type: \"minus\"} : minus), \"primary\"], \"postprocess\": p.negative},\n    {\"name\": \"primary\", \"symbols\": [\"dynamicCell\"], \"postprocess\": id},\n    {\"name\": \"dynamicCell\", \"symbols\": [(lexer.has(\"lsquare\") ? {type: \"lsquare\"} : lsquare), \"sum\", (lexer.has(\"semicolon\") ? {type: \"semicolon\"} : semicolon), \"sum\", (lexer.has(\"rsquare\") ? {type: \"rsquare\"} : rsquare)], \"postprocess\": p.dynamicCell},\n    {\"name\": \"cell\", \"symbols\": [(lexer.has(\"cell\") ? {type: \"cell\"} : cell)], \"postprocess\": p.cell},\n    {\"name\": \"variable\", \"symbols\": [(lexer.has(\"identifier\") ? {type: \"identifier\"} : identifier)], \"postprocess\": p.variable},\n    {\"name\": \"function_call\", \"symbols\": [(lexer.has(\"identifier\") ? {type: \"identifier\"} : identifier), (lexer.has(\"lparen\") ? {type: \"lparen\"} : lparen), \"args\", (lexer.has(\"rparen\") ? {type: \"rparen\"} : rparen)], \"postprocess\": p.functionCall},\n    {\"name\": \"function_call\", \"symbols\": [(lexer.has(\"kwIf\") ? {type: \"kwIf\"} : kwIf), (lexer.has(\"lparen\") ? {type: \"lparen\"} : lparen), \"args\", (lexer.has(\"rparen\") ? {type: \"rparen\"} : rparen)], \"postprocess\": p.functionCall},\n    {\"name\": \"args$ebnf$1\", \"symbols\": []},\n    {\"name\": \"args$ebnf$1$subexpression$1\", \"symbols\": [(lexer.has(\"comma\") ? {type: \"comma\"} : comma), \"expr\"]},\n    {\"name\": \"args$ebnf$1\", \"symbols\": [\"args$ebnf$1\", \"args$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"args\", \"symbols\": [\"expr\", \"args$ebnf$1\"], \"postprocess\": p.argsList},\n    {\"name\": \"args\", \"symbols\": [], \"postprocess\": p.emptyList},\n    {\"name\": \"range\", \"symbols\": [\"cell\", (lexer.has(\"colon\") ? {type: \"colon\"} : colon), \"cell\"], \"postprocess\": p.range},\n    {\"name\": \"entry$ebnf$1\", \"symbols\": []},\n    {\"name\": \"entry$ebnf$1$subexpression$1\", \"symbols\": [(lexer.has(\"end\") ? {type: \"end\"} : end)]},\n    {\"name\": \"entry$ebnf$1\", \"symbols\": [\"entry$ebnf$1\", \"entry$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"entry$ebnf$2\", \"symbols\": []},\n    {\"name\": \"entry$ebnf$2$subexpression$1\", \"symbols\": [(lexer.has(\"end\") ? {type: \"end\"} : end)]},\n    {\"name\": \"entry$ebnf$2\", \"symbols\": [\"entry$ebnf$2\", \"entry$ebnf$2$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"entry\", \"symbols\": [\"entry$ebnf$1\", \"code\", \"entry$ebnf$2\"], \"postprocess\": (data) => [data[1]]},\n    {\"name\": \"code$ebnf$1\", \"symbols\": []},\n    {\"name\": \"code$ebnf$1$subexpression$1\", \"symbols\": [\"statement\"]},\n    {\"name\": \"code$ebnf$1\", \"symbols\": [\"code$ebnf$1\", \"code$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"code\", \"symbols\": [\"statement\", \"code$ebnf$1\"], \"postprocess\": p.list},\n    {\"name\": \"statement\", \"symbols\": [\"expr\", \"ends\"], \"postprocess\": id},\n    {\"name\": \"statement\", \"symbols\": [\"reference\", \"ends\"], \"postprocess\": id},\n    {\"name\": \"statement\", \"symbols\": [\"return\", \"ends\"], \"postprocess\": id},\n    {\"name\": \"statement\", \"symbols\": [\"assigment\", \"ends\"], \"postprocess\": id},\n    {\"name\": \"statement$ebnf$1\", \"symbols\": []},\n    {\"name\": \"statement$ebnf$1$subexpression$1\", \"symbols\": [(lexer.has(\"end\") ? {type: \"end\"} : end)]},\n    {\"name\": \"statement$ebnf$1\", \"symbols\": [\"statement$ebnf$1\", \"statement$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"statement\", \"symbols\": [\"blockStatement\", \"statement$ebnf$1\"], \"postprocess\": id},\n    {\"name\": \"blockStatement\", \"symbols\": [(lexer.has(\"kwWhile\") ? {type: \"kwWhile\"} : kwWhile), \"expr\", \"ends\", \"block\"], \"postprocess\": p.whileLoop},\n    {\"name\": \"blockStatement$ebnf$1$subexpression$1\", \"symbols\": [\"else\"]},\n    {\"name\": \"blockStatement$ebnf$1\", \"symbols\": [\"blockStatement$ebnf$1$subexpression$1\"], \"postprocess\": id},\n    {\"name\": \"blockStatement$ebnf$1\", \"symbols\": [], \"postprocess\": function(d) {return null;}},\n    {\"name\": \"blockStatement\", \"symbols\": [(lexer.has(\"kwIf\") ? {type: \"kwIf\"} : kwIf), \"expr\", \"ends\", \"block\", \"blockStatement$ebnf$1\"], \"postprocess\": p.ifElse},\n    {\"name\": \"blockStatement\", \"symbols\": [(lexer.has(\"kwDef\") ? {type: \"kwDef\"} : kwDef), (lexer.has(\"identifier\") ? {type: \"identifier\"} : identifier), (lexer.has(\"lparen\") ? {type: \"lparen\"} : lparen), \"params\", (lexer.has(\"rparen\") ? {type: \"rparen\"} : rparen), \"ends\", \"block\"], \"postprocess\": p.functionDef},\n    {\"name\": \"else\", \"symbols\": [(lexer.has(\"kwElse\") ? {type: \"kwElse\"} : kwElse), \"ends\", \"block\"], \"postprocess\": p.elseBlock},\n    {\"name\": \"assigment\", \"symbols\": [\"variable\", (lexer.has(\"assign\") ? {type: \"assign\"} : assign), \"expr\"], \"postprocess\": p.assigment},\n    {\"name\": \"assigment\", \"symbols\": [\"cell\", (lexer.has(\"assign\") ? {type: \"assign\"} : assign), \"expr\"], \"postprocess\": p.assigment},\n    {\"name\": \"assigment\", \"symbols\": [\"dynamicCell\", (lexer.has(\"assign\") ? {type: \"assign\"} : assign), \"expr\"], \"postprocess\": p.assigment},\n    {\"name\": \"block\", \"symbols\": [(lexer.has(\"indent\") ? {type: \"indent\"} : indent), \"code\", (lexer.has(\"dedent\") ? {type: \"dedent\"} : dedent)], \"postprocess\": p.block},\n    {\"name\": \"ends$ebnf$1$subexpression$1\", \"symbols\": [(lexer.has(\"end\") ? {type: \"end\"} : end)]},\n    {\"name\": \"ends$ebnf$1\", \"symbols\": [\"ends$ebnf$1$subexpression$1\"]},\n    {\"name\": \"ends$ebnf$1$subexpression$2\", \"symbols\": [(lexer.has(\"end\") ? {type: \"end\"} : end)]},\n    {\"name\": \"ends$ebnf$1\", \"symbols\": [\"ends$ebnf$1\", \"ends$ebnf$1$subexpression$2\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"ends\", \"symbols\": [\"ends$ebnf$1\"], \"postprocess\": null},\n    {\"name\": \"reference\", \"symbols\": [(lexer.has(\"identifier\") ? {type: \"identifier\"} : identifier), (lexer.has(\"assign\") ? {type: \"assign\"} : assign), (lexer.has(\"ampersand\") ? {type: \"ampersand\"} : ampersand), \"range\"], \"postprocess\": p.reference},\n    {\"name\": \"reference\", \"symbols\": [(lexer.has(\"identifier\") ? {type: \"identifier\"} : identifier), (lexer.has(\"assign\") ? {type: \"assign\"} : assign), (lexer.has(\"ampersand\") ? {type: \"ampersand\"} : ampersand), \"cell\"], \"postprocess\": p.reference},\n    {\"name\": \"reference\", \"symbols\": [(lexer.has(\"identifier\") ? {type: \"identifier\"} : identifier), (lexer.has(\"assign\") ? {type: \"assign\"} : assign), (lexer.has(\"ampersand\") ? {type: \"ampersand\"} : ampersand), \"variable\"], \"postprocess\": p.reference},\n    {\"name\": \"return\", \"symbols\": [(lexer.has(\"kwReturn\") ? {type: \"kwReturn\"} : kwReturn), \"expr\"], \"postprocess\": p.returnNode},\n    {\"name\": \"params$ebnf$1\", \"symbols\": []},\n    {\"name\": \"params$ebnf$1$subexpression$1\", \"symbols\": [(lexer.has(\"comma\") ? {type: \"comma\"} : comma), \"variable\"]},\n    {\"name\": \"params$ebnf$1\", \"symbols\": [\"params$ebnf$1\", \"params$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"params\", \"symbols\": [\"variable\", \"params$ebnf$1\"], \"postprocess\": p.argsList},\n    {\"name\": \"params\", \"symbols\": [], \"postprocess\": p.emptyList}\n];\nlet ParserStart = \"entry\";\nexport default { Lexer, ParserRules, ParserStart };\n","// Generated automatically by nearley, version 2.19.1\n// http://github.com/Hardmath123/nearley\nfunction id(x) { return x[0]; }\n\n  /* eslint-disable */\n  import * as p from './parserPostProcessors.js'\n  import {lexer} from './lexer.js'\nlet Lexer = lexer;\nlet ParserRules = [\n    {\"name\": \"formulaEntry\", \"symbols\": [\"sum\"]},\n    {\"name\": \"expr\", \"symbols\": [\"comparison\"], \"postprocess\": id},\n    {\"name\": \"comparison\", \"symbols\": [\"sum\"], \"postprocess\": id},\n    {\"name\": \"comparison\", \"symbols\": [\"sum\", (lexer.has(\"equal\") ? {type: \"equal\"} : equal), \"sum\"], \"postprocess\": p.equal},\n    {\"name\": \"comparison\", \"symbols\": [\"sum\", (lexer.has(\"greaterEqual\") ? {type: \"greaterEqual\"} : greaterEqual), \"sum\"], \"postprocess\": p.greaterEqual},\n    {\"name\": \"comparison\", \"symbols\": [\"sum\", (lexer.has(\"lessEqual\") ? {type: \"lessEqual\"} : lessEqual), \"sum\"], \"postprocess\": p.lessEqual},\n    {\"name\": \"comparison\", \"symbols\": [\"sum\", (lexer.has(\"less\") ? {type: \"less\"} : less), \"sum\"], \"postprocess\": p.less},\n    {\"name\": \"comparison\", \"symbols\": [\"sum\", (lexer.has(\"greater\") ? {type: \"greater\"} : greater), \"sum\"], \"postprocess\": p.greater},\n    {\"name\": \"comparison\", \"symbols\": [\"sum\", (lexer.has(\"notEqual\") ? {type: \"notEqual\"} : notEqual), \"sum\"], \"postprocess\": p.notEqual},\n    {\"name\": \"sum\", \"symbols\": [\"product\"], \"postprocess\": id},\n    {\"name\": \"sum\", \"symbols\": [\"sum\", (lexer.has(\"plus\") ? {type: \"plus\"} : plus), \"product\"], \"postprocess\": p.addition},\n    {\"name\": \"sum\", \"symbols\": [\"sum\", (lexer.has(\"minus\") ? {type: \"minus\"} : minus), \"product\"], \"postprocess\": p.subtraction},\n    {\"name\": \"product\", \"symbols\": [\"primary\"], \"postprocess\": id},\n    {\"name\": \"product\", \"symbols\": [\"product\", (lexer.has(\"asterisk\") ? {type: \"asterisk\"} : asterisk), \"primary\"], \"postprocess\": p.multiplication},\n    {\"name\": \"product\", \"symbols\": [\"product\", (lexer.has(\"slash\") ? {type: \"slash\"} : slash), \"primary\"], \"postprocess\": p.division},\n    {\"name\": \"primary\", \"symbols\": [(lexer.has(\"lparen\") ? {type: \"lparen\"} : lparen), \"expr\", (lexer.has(\"rparen\") ? {type: \"rparen\"} : rparen)], \"postprocess\": (data) => data[1]},\n    {\"name\": \"primary\", \"symbols\": [(lexer.has(\"number\") ? {type: \"number\"} : number)], \"postprocess\": p.number},\n    {\"name\": \"primary\", \"symbols\": [\"variable\"], \"postprocess\": id},\n    {\"name\": \"primary\", \"symbols\": [\"function_call\"], \"postprocess\": id},\n    {\"name\": \"primary\", \"symbols\": [\"range\"], \"postprocess\": id},\n    {\"name\": \"primary\", \"symbols\": [\"cell\"], \"postprocess\": id},\n    {\"name\": \"primary\", \"symbols\": [(lexer.has(\"minus\") ? {type: \"minus\"} : minus), \"primary\"], \"postprocess\": p.negative},\n    {\"name\": \"primary\", \"symbols\": [\"dynamicCell\"], \"postprocess\": id},\n    {\"name\": \"dynamicCell\", \"symbols\": [(lexer.has(\"lsquare\") ? {type: \"lsquare\"} : lsquare), \"sum\", (lexer.has(\"semicolon\") ? {type: \"semicolon\"} : semicolon), \"sum\", (lexer.has(\"rsquare\") ? {type: \"rsquare\"} : rsquare)], \"postprocess\": p.dynamicCell},\n    {\"name\": \"cell\", \"symbols\": [(lexer.has(\"cell\") ? {type: \"cell\"} : cell)], \"postprocess\": p.cell},\n    {\"name\": \"variable\", \"symbols\": [(lexer.has(\"identifier\") ? {type: \"identifier\"} : identifier)], \"postprocess\": p.variable},\n    {\"name\": \"function_call\", \"symbols\": [(lexer.has(\"identifier\") ? {type: \"identifier\"} : identifier), (lexer.has(\"lparen\") ? {type: \"lparen\"} : lparen), \"args\", (lexer.has(\"rparen\") ? {type: \"rparen\"} : rparen)], \"postprocess\": p.functionCall},\n    {\"name\": \"function_call\", \"symbols\": [(lexer.has(\"kwIf\") ? {type: \"kwIf\"} : kwIf), (lexer.has(\"lparen\") ? {type: \"lparen\"} : lparen), \"args\", (lexer.has(\"rparen\") ? {type: \"rparen\"} : rparen)], \"postprocess\": p.functionCall},\n    {\"name\": \"args$ebnf$1\", \"symbols\": []},\n    {\"name\": \"args$ebnf$1$subexpression$1\", \"symbols\": [(lexer.has(\"comma\") ? {type: \"comma\"} : comma), \"expr\"]},\n    {\"name\": \"args$ebnf$1\", \"symbols\": [\"args$ebnf$1\", \"args$ebnf$1$subexpression$1\"], \"postprocess\": function arrpush(d) {return d[0].concat([d[1]]);}},\n    {\"name\": \"args\", \"symbols\": [\"expr\", \"args$ebnf$1\"], \"postprocess\": p.argsList},\n    {\"name\": \"args\", \"symbols\": [], \"postprocess\": p.emptyList},\n    {\"name\": \"range\", \"symbols\": [\"cell\", (lexer.has(\"colon\") ? {type: \"colon\"} : colon), \"cell\"], \"postprocess\": p.range}\n];\nlet ParserStart = \"formulaEntry\";\nexport default { Lexer, ParserRules, ParserStart };\n","import * as nearley from 'nearley';\nimport grammar from \"./grammar.js\";\nimport formulaGrammar from \"./formulaGrammar.js\";\n\nimport {UserError} from \"./errors\";\n\nexport class Parser {\n  constructor() {\n    this.parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));\n  }\n\n  feed(s) {\n    try {\n      this.parser.feed(s);\n    } catch (e) {\n      throw new UserError(e.message);\n    }\n  }\n\n  get results() {\n    try {\n      return this.parser.results[0][0];\n    }catch (e) {\n      return null;\n    }\n  }\n}\n\n\nexport class FormulaParser {\n  constructor() {\n    this.parser = new nearley.Parser(nearley.Grammar.fromCompiled(formulaGrammar));\n  }\n\n  feed(s) {\n    try {\n      this.parser.feed(s);\n    } catch (e) {\n      throw new UserError(\"Syntax error\");\n    }\n  }\n\n  get results() {\n    try {\n      return this.parser.results[0][0];\n    }catch (e) {\n      return null;\n    }\n  }\n}\n","export class Variable {\n\n  value = null;\n\n  constructor(value) {\n    this.value = value;\n  }\n}\n","import {observable} from \"mobx\";\n\nexport class Cell {\n\n  @observable formula = null;\n  @observable value = null;\n  @observable background = null;\n  @observable error = null;\n\n  ast = null;\n  // vars that observe us -> we are used in their formula\n  observers = [];\n  // vars that we observe for changes -> we use them in our formula\n  subjects = [];\n\n  constructor(x, y, label) {\n    this.x = x;\n    this.y = y;\n    this.label = label;\n  }\n\n  reset() {\n    this.formula = null\n    this.value = null\n    this.background = null\n    this.error = null\n    this.ast = null;\n    this.observers = [];\n    this.subjects = [];\n  }\n\n  unregisterFromAllSubjects() {\n    for (const cell of this.subjects) {\n      cell._unregisterObserver(this);\n    }\n    this.subjects = [];\n  }\n\n  observe(cell) {\n    cell.observers.push(this);\n    this.subjects.push(cell);\n  }\n\n  _unregisterObserver(v) {\n    const index = this.observers.indexOf(v);\n    if (index === this.observers.length - 1) {\n      this.observers.pop();\n    } else {\n      this.observers[index] = this.observers.pop();\n    }\n  }\n}\n","import {UserError} from \"../parser/errors\";\nimport {FormulaParser} from \"../parser/parsers\";\nimport {isFormula, letterLabelGenerator, topologicalSort} from \"../utils\";\nimport {Variable} from \"./Variable\";\nimport {Cell} from \"./Cell\";\nimport {ReferenceNode} from \"../nodes/ReferenceNode\";\n\nexport class Environment {\n\n  constructor(x, y) {\n    this.funcitons = {};\n    this.x = x;\n    this.y = y;\n    this.cells = Array(y);\n    for (let i = 0; i < y; i++) {\n      this.cells[i] = Array(x);\n      const gen = letterLabelGenerator();\n      for (let j = 0; j < x; j++) {\n        const label = gen.next().value + (i + 1).toString();\n        this.cells[i][j] = new Cell(j, i, label);\n      }\n    }\n\n    // new scope is only used in functions (to prevent them from accessing external variables)\n    this.variablesScopes = [{}];\n    this.referencesScopes = [{}];\n  }\n\n  reset() {\n    for (let i = 0; i < this.y; i++) {\n      for (let j = 0; j < this.x; j++) {\n        this.cells[i][j].reset();\n      }\n    }\n\n  }\n\n  setCell(x, y, string) {\n    const cell = this.getCell(x, y);\n    cell.unregisterFromAllSubjects();\n    try {\n      if (isFormula(string)) {\n        if (string.length === 1) {\n          return\n        }\n        this._setCellFormula(cell, string);\n      } else {\n        this._setCellValue(cell, string);\n      }\n\n      this._updateObservers(cell);\n      cell.error = null;\n    } catch (e) {\n      if (e.name !== \"UserError\") {\n        throw e;\n      }\n      cell.error = e.message;\n    }\n  }\n\n\n  _setCellFormula(cell, formula) {\n    cell.formula = formula;\n    const parser = new FormulaParser();\n    parser.feed(formula.substring(1));\n    cell.ast = parser.results;\n    cell.value = cell.ast.exec(this);\n\n    debugger\n    const varsReferenced = cell.ast.findCellsReferenced(this);\n    for (const v of varsReferenced) {\n      cell.observe(v);\n    }\n  }\n\n  _setCellValue(variable, value) {\n    const x = parseFloat(value);\n    if (!isNaN(x)) {\n      variable.value = x;\n    } else {\n      variable.value = value;\n    }\n    variable.formula = null;\n    variable.ast = null;\n  }\n\n\n  getCellsByRange(start, end) {\n\n    const x1 = start.x;\n    const y1 = start.y;\n    const x2 = start.x;\n    const y2 = start.y;\n\n    if (this.x <= x1 || this.y <= y1) {\n      throw new UserError(`No cell: ${start}`)\n    }\n    if (this.x <= x2 || this.y <= y2) {\n      throw new UserError(`No cell: ${end}`)\n    }\n\n    const result = [];\n\n    for (let i = y1; i <= y2; i++) {\n      for (let j = x1; j <= x2; j++) {\n        result.push(this.cells[i][j]);\n      }\n    }\n\n    return result;\n  }\n\n  getCell(x, y) {\n    let cell;\n    try {\n      cell = this.cells[y][x];\n    } catch (e) {\n    }\n    if (cell === undefined) {\n      throw new UserError(\"No such cell\");\n    }\n    return cell;\n  }\n\n\n  _updateObservers(cell) {\n    for (const x of topologicalSort(cell)) {\n      x.value = x.ast.exec(this);\n    }\n  }\n\n\n  setVariable(identifier, value) {\n    const variables = this.variablesScopes[this.variablesScopes.length - 1];\n    let variable;\n    try {\n      variable = this.getVarByName(identifier);\n      variable.value = value;\n    } catch (e) {\n      variables[identifier] = new Variable(value);\n    }\n  }\n\n\n  getVarByName(identifier) {\n    const variables = this.variablesScopes[this.variablesScopes.length - 1];\n    if (variables.hasOwnProperty(identifier)) {\n      return variables[identifier];\n    } else {\n      throw new UserError(`No variable: ${identifier}`);\n    }\n  }\n\n  setReference(identifier, node) {\n    this.referencesScopes[this.referencesScopes.length - 1][identifier] = node;\n  }\n\n  getReference(identifier) {\n    let x = this.referencesScopes[this.referencesScopes.length - 1][identifier];\n    if (x instanceof ReferenceNode) {\n      x = this.getReference(x.identifier);\n    }\n    return x;\n  }\n\n  setFunction(identifier, args, block) {\n    this.funcitons[identifier] = {args: args, block: block};\n  }\n\n  getFunction(identifier) {\n    if (!this.funcitons.hasOwnProperty(identifier)) {\n      throw new UserError(`No function: ${identifier}`);\n    }\n    return this.funcitons[identifier];\n  }\n\n  newScope() {\n    this.variablesScopes.push({});\n    this.referencesScopes.push({});\n  }\n\n  popScope() {\n    this.variablesScopes.pop();\n    this.referencesScopes.pop();\n  }\n\n}\n","import {Environment} from \"../environment/Environment\";\nimport {Parser} from \"../parser/parsers\";\nimport {lexer} from \"../parser/lexer\";\nimport {observable} from \"mobx\";\n\n\nexport class SpreadsheetStore {\n\n  @observable annotations = []\n\n  constructor(x, y) {\n    this.env = new Environment(x, y);\n  }\n\n  reset() {\n    this.env.reset()\n  }\n\n  onCellSet(x, y, value) {\n    this.env.setCell(x, y, value);\n  }\n\n  cellsToObjects() {\n    const result = {};\n\n    for (let i = 0; i < this.env.y; i++) {\n      for (let j = 0; j < this.env.x; j++) {\n        const cell = this.env.getCell(j, i);\n        let x;\n        if (cell.formula) {\n          x = cell.formula\n        } else if (cell.value) {\n          x = cell.value;\n        } else {\n          continue;\n        }\n        result[cell.label] = x;\n      }\n    }\n    return result\n  }\n\n  run(code) {\n    this.annotations = []\n    if (code === \"\") {\n      return;\n    }\n    try {\n      const parser = new Parser();\n      parser.feed(code);\n      for (const line of parser.results) {\n        line.exec(this.env);\n      }\n    } catch (e) {\n      if (e.name !== \"UserError\") {\n        throw e;\n      }\n\n      const regex = /.*line (\\d*).*col (\\d*)/gm;\n\n      const m = regex.exec(e.message)\n      if (m !== null) {\n        const line = parseInt(m[1]) - 1\n        const col = parseInt(m[2])\n        const lines = e.message.split(\"\\n\");\n        const n = Math.min(5, lines.length)\n        let message = \"\"\n        if (4 in lines) {\n          lines[4] = lines[4].substring(0, lines[4].indexOf(\"Instead\"));\n        }\n        for (let i = 0; i < n; i++) {\n          message +=lines[i] + '\\n'\n        }\n        this.annotations = [{row: line, column: col, type: 'error', text: message}];\n      } else {\n        this.annotations = [{row: 0, column: 0, type: 'error', text: e.message}];\n      }\n      console.log(e.message)\n    }\n  }\n\n  logParseTree(code) {\n    this.annotations = []\n    try {\n      const parser = new Parser();\n      parser.feed(code);\n      console.log(parser.results);\n    } catch (e) {\n      if (e.name !== \"UserError\") {\n        throw e;\n      }\n      console.log(e.message);\n    }\n  }\n\n  logLexerOutput(code) {\n    this.annotations = []\n    try {\n      lexer.reset(code);\n      const result = [];\n      let tok = lexer.next();\n      while (tok !== undefined) {\n        result.push(tok);\n        tok = lexer.next()\n      }\n      console.log(result);\n    } catch (e) {\n      if (e.name !== \"UserError\") {\n        throw e;\n      }\n\n      console.log(e.message);\n    }\n  }\n\n}\n","import React, {useState} from 'react';\nimport PropTypes from 'prop-types';\nimport style from './Editor.module.scss';\nimport AceEditor from \"react-ace\";\n\nimport \"ace-builds/src-noconflict/theme-cobalt\";\nimport \"ace-builds/src-noconflict/mode-python\";\nimport \"ace-builds/webpack-resolver\";\nimport {store} from \"./App\";\nimport {observer} from \"mobx-react\";\n\n\nconst Editor = props => {\n\n  let [code, setCodeState] = useState(\"\");\n\n  // todo document this\n  const setCode = (code) => {\n    if (code[code.length - 1] !== '\\n') {\n      code += '\\n';\n    }\n    setCodeState(code);\n  }\n\n  const onLoad = e => {\n\n    const file = e.target.files[0];\n    const fr = new FileReader();\n\n    fr.addEventListener('load', e => {\n      const text = e.target.result;\n      const o = JSON.parse(text);\n\n      const code = o.code;\n      const cells = o.cells\n\n      setCode(code);\n      props.onSubmit(code)\n      props.onLoad(cells)\n    })\n    fr.readAsText(file);\n\n  };\n\n  return (\n    <div className={style.Editor}>\n\n      <div className={style.Top}>\n        <label className={style.customFileUpload}> Load <input type=\"file\" onChange={onLoad}/> </label>\n        <button onClick={() => props.onSave(code)}>Save</button>\n      </div>\n\n      <AceEditor\n        mode=\"python\"\n        theme=\"cobalt\"\n        onChange={setCode}\n        value={code}\n        height={'100%'}\n        width={'100%'}\n        annotations={store.annotations}\n      />\n      <div className={style.Bottom}>\n        <button onClick={() => props.onLogParseTree(code)}>Log parse tree</button>\n        <button onClick={() => props.onLogLexerOutput(code)}>Log tokens</button>\n        <button onClick={() => props.onSubmit(code)}>Run</button>\n      </div>\n    </div>\n  );\n};\n\nEditor.propTypes = {\n  onSubmit: PropTypes.func.isRequired,\n  onSave: PropTypes.func.isRequired,\n  onLoad: PropTypes.func.isRequired,\n  onLogLexerOutput: PropTypes.func.isRequired,\n  onLogParseTree: PropTypes.func.isRequired,\n  error: PropTypes.string,\n  annotations: PropTypes.array,\n};\n\n\nexport default observer(Editor);\n","/* eslint-disable no-eval */\nimport React from 'react';\nimport Spreadsheet from \"./Spreadsheet\";\nimport {SpreadsheetStore} from \"../mobx/SpreadsheetStore\";\nimport style from './App.module.scss';\nimport Editor from \"./Editor\";\nimport {saveAs} from 'file-saver';\nimport {getCellIndexes} from \"../utils\";\nimport {observer} from \"mobx-react\";\n\n\nconst x = 5;\nconst y = 30;\n\nexport const store = new SpreadsheetStore(x, y);\n\nfunction onSave(code,store) {\n  const cells = store.cellsToObjects();\n  const o = {\n    'cells': cells,\n    'code': code,\n  };\n  const blob = new Blob([JSON.stringify(o,null,1)], {\n    type:'text/plain;charset=utf-8'\n  })\n  saveAs(blob, \"spreadsheet.txt\");\n}\n\nfunction onLoad(cells) {\n  store.reset()\n\n  for (const p in cells) {\n    if (cells.hasOwnProperty(p)) {\n      try{\n        const indexes = getCellIndexes(p);\n        const x = indexes.x;\n        const y = indexes.y;\n        store.onCellSet(x,y,cells[p])\n      }\n      catch (e) {\n\n      }\n    }\n  }\n}\n\nfunction App() {\n\n  // useEffect(populateSheet, []);\n\n  return (\n    <div className={style.App}>\n      <Spreadsheet\n        x={store.env.x}\n        y={store.env.y}\n        cells={store.env.cells}\n        onCellSet={(x,y,v) => store.onCellSet(x,y,v)}\n      />\n      <Editor\n        onLoad={cells=>onLoad(cells)}\n        onSave={x=>onSave(x,store)}\n        onSubmit={(code) => store.run(code)}\n        onLogLexerOutput={(code) => store.logLexerOutput(code)}\n        onLogParseTree={(code) => store.logParseTree(code)}\n      />\n    </div>\n  );\n}\n\nexport default observer(App);\n\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n  // [::1] is the IPv6 localhost address.\n  window.location.hostname === '[::1]' ||\n  // 127.0.0.0/8 are considered localhost for IPv4.\n  window.location.hostname.match(\n    /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n  )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n            'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: {'Service-Worker': 'script'}\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App/>, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","export const returnMessage = \"Return in unexpected place\"\n\nexport class UserError extends Error {\n  constructor(...params) {\n    super(...params);\n    this.name = \"UserError\";\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, UserError);\n    }\n  }\n}\n\nexport class returnHandler extends Error {\n  constructor(result,...params) {\n    super(...params);\n    this.result = result;\n    this.name = \"returnHandler\";\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, UserError);\n    }\n  }\n}\n"],"sourceRoot":""}